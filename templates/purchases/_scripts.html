<script>
document.addEventListener("DOMContentLoaded", function () {
  const form = document.getElementById("purchase-form");

  const storeSelect    = document.getElementById("store_id");
  const supplierSelect = document.getElementById("supplier_id");
  const dateInput      = document.getElementById("delivery_date");
  const focusHidden    = document.getElementById("focus_after_reload");

  const tbody         = document.getElementById("item-rows");
  const rowCountInput = document.getElementById("row_count");
  const addBtn        = document.getElementById("add-row-btn");

  if (!tbody) return;

  let baseItems = [];

  /* ===============================
     Focus restore / default focus
  =============================== */
  function focusFirstItemCell() {
    const first = tbody.querySelector(".item-autocomplete");
    if (first) first.focus();
  }

  let focused = false;
  const nextFocus = sessionStorage.getItem("nextFocus");
  if (nextFocus) {
    sessionStorage.removeItem("nextFocus");
    setTimeout(() => {
      if (nextFocus === "supplier" && supplierSelect) supplierSelect.focus();
      else if (nextFocus === "date" && dateInput) dateInput.focus();
      else if (nextFocus === "firstItem") focusFirstItemCell();
    }, 0);
    focused = true;
  }

  if (!focused) {
    const focusAfter = focusHidden?.value || "";
    if (focusAfter === "supplier") supplierSelect?.focus();
    else storeSelect?.focus(); // default: store
  }

  function moveFocusByEnter(el, nextFn) {
    if (!el) return;
    el.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        nextFn();
      }
    });
  }

  // store -> supplier
  if (storeSelect && supplierSelect) {
    moveFocusByEnter(storeSelect, () => supplierSelect.focus());

    storeSelect.addEventListener("change", () => {
      sessionStorage.setItem("nextFocus", "supplier");
      const url = new URL(window.location.href);
      url.searchParams.set("store_id", storeSelect.value || "");
      window.location.href = url.toString();
    });
  }

  // supplier -> date
  moveFocusByEnter(supplierSelect, () => dateInput?.focus());

  // date -> first item
  moveFocusByEnter(dateInput, () => focusFirstItemCell());

  /* ===============================
     Supplier -> Load items
  =============================== */
  async function loadItems(supplierId) {
    baseItems = [];
    if (!supplierId) return;

    try {
      const resp = await fetch(`/api/items/by_supplier/${supplierId}`);
      const data = await resp.json();
      baseItems = Array.isArray(data) ? data : [];
    } catch (e) {
      baseItems = [];
      console.error("Failed to load items:", e);
    }
  }

  if (supplierSelect) {
    if (supplierSelect.value) loadItems(supplierSelect.value);

    supplierSelect.addEventListener("change", (e) => {
      loadItems(e.target.value);

      // clear suggestions/ids when supplier changes
      tbody.querySelectorAll(".item-autocomplete").forEach(inp => inp.value = "");
      tbody.querySelectorAll(".item-id").forEach(h => h.value = "");
      tbody.querySelectorAll(".item-suggestions").forEach(box => {
        box.hidden = true;
        box.innerHTML = "";
      });
    });
  }

  /* ===============================
     Autocomplete
  =============================== */
  function getText(it) {
    return (it.name || "").trim();
  }
  function closeBox(box) {
    box.hidden = true;
    box.innerHTML = "";
  }
  function openBox(box) {
    box.hidden = false;
  }
  function setActive(items, index) {
    items.forEach(el => el.classList.remove("active"));
    if (items[index]) {
      items[index].classList.add("active");
      items[index].scrollIntoView({ block: "nearest" });
    }
  }
  function getCellElements(input) {
    const cell = input.closest(".item-cell");
    if (!cell) return {};
    return {
      cell,
      hidden: cell.querySelector(".item-id"),
      box: cell.querySelector(".item-suggestions"),
    };
  }

  function buildSuggestions(input, hidden, box, forceOpen = false) {
    const q = (input.value || "").trim().toLowerCase();
    box.innerHTML = "";

    const shouldShow = forceOpen || q.length > 0;
    if (!shouldShow || baseItems.length === 0) {
      closeBox(box);
      return;
    }

    const matched = baseItems
      .filter(it => {
        const text = getText(it).toLowerCase();
        return forceOpen ? true : text.includes(q);
      })
      .slice(0, 30);

    if (matched.length === 0) {
      closeBox(box);
      return;
    }

    matched.forEach((it) => {
      const div = document.createElement("div");
      div.className = "item-suggest-item";
      div.textContent = getText(it);
      div.dataset.id = it.id;
      div.dataset.unit = (it.unit ?? "").toString();

      div.addEventListener("mousedown", (ev) => {
        ev.preventDefault();
        selectItem(input, hidden, box, it);
      });

      box.appendChild(div);
    });

    openBox(box);
    const items = Array.from(box.querySelectorAll(".item-suggest-item"));
    if (items.length > 0) setActive(items, 0);
  }

  function selectItem(input, hidden, box, item) {
    input.value = getText(item);
    hidden.value = item.id;
    closeBox(box);

    const tr = input.closest("tr");
    const qty = tr ? tr.querySelector(".qty-input") : null;
    if (qty && !qty.value && item.unit != null && String(item.unit) !== "") {
      qty.value = item.unit;
    }
    qty?.focus();
  }

  tbody.addEventListener("input", (e) => {
    const input = e.target;
    if (!input.classList.contains("item-autocomplete")) return;

    const { hidden, box } = getCellElements(input);
    if (!hidden || !box) return;

    hidden.value = "";
    buildSuggestions(input, hidden, box, false);
  });

  tbody.addEventListener("focusin", (e) => {
    const input = e.target;
    if (!input.classList.contains("item-autocomplete")) return;

    const { hidden, box } = getCellElements(input);
    if (!hidden || !box) return;

    buildSuggestions(input, hidden, box, true);
  });

  tbody.addEventListener("keydown", (e) => {
    const input = e.target;
    if (!input.classList.contains("item-autocomplete")) return;

    const { hidden, box } = getCellElements(input);
    if (!hidden || !box) return;

    const isOpen = !box.hidden;

    if (e.key === "ArrowDown") {
      e.preventDefault();
      e.stopPropagation();
      if (!isOpen) return buildSuggestions(input, hidden, box, true);

      const list = Array.from(box.querySelectorAll(".item-suggest-item"));
      let idx = list.findIndex(el => el.classList.contains("active"));
      idx = (idx < 0) ? 0 : Math.min(idx + 1, list.length - 1);
      return setActive(list, idx);
    }

    if (e.key === "ArrowUp" && isOpen) {
      e.preventDefault();
      e.stopPropagation();
      const list = Array.from(box.querySelectorAll(".item-suggest-item"));
      let idx = list.findIndex(el => el.classList.contains("active"));
      idx = (idx < 0) ? 0 : Math.max(idx - 1, 0);
      return setActive(list, idx);
    }

    if (e.key === "Enter" && isOpen) {
      e.preventDefault();
      e.stopPropagation();

      const list = Array.from(box.querySelectorAll(".item-suggest-item"));
      const idx = list.findIndex(el => el.classList.contains("active"));
      if (idx >= 0) {
        const it = {
          id: list[idx].dataset.id || "",
          unit: list[idx].dataset.unit || "",
          name: list[idx].textContent || ""
        };
        input.value = it.name;
        hidden.value = it.id;
        closeBox(box);

        const tr = input.closest("tr");
        const qty = tr ? tr.querySelector(".qty-input") : null;
        if (qty && !qty.value && it.unit) qty.value = it.unit;
        qty?.focus();
      }
      return;
    }

    if (e.key === "Escape" && isOpen) {
      e.preventDefault();
      e.stopPropagation();
      closeBox(box);
    }
  });

  document.addEventListener("click", (e) => {
    document.querySelectorAll(".item-cell").forEach((cell) => {
      const box = cell.querySelector(".item-suggestions");
      if (!box) return;
      if (!cell.contains(e.target)) closeBox(box);
    });
  });

  /* ===============================
     Calculation
  =============================== */
  function parseIntSafe(v) {
    if (!v) return 0;
    return parseInt(String(v).replace(/,/g, ""), 10) || 0;
  }

  function recalcRow(tr) {
    const qty   = tr.querySelector(".qty-input");
    const price = tr.querySelector(".price-input");
    const amt   = tr.querySelector(".amount-display");
    if (!qty || !price || !amt) return;

    const total = parseIntSafe(qty.value) * parseIntSafe(price.value);
    amt.value = total ? total.toLocaleString("ja-JP") : "";
  }

  function recalcAll() {
    tbody.querySelectorAll("tr").forEach(recalcRow);

    const totalCell = document.getElementById("total_amount_display");
    if (!totalCell) return;

    let sum = 0;
    document.querySelectorAll(".amount-display").forEach(el => {
      sum += parseIntSafe(el.value);
    });
    totalCell.textContent = sum ? sum.toLocaleString("ja-JP") : "";
  }

  tbody.addEventListener("input", (e) => {
    if (e.target.classList.contains("qty-input") || e.target.classList.contains("price-input")) {
      const tr = e.target.closest("tr");
      if (tr) recalcRow(tr);
      recalcAll();
    }
  }, true);

  /* ===============================
     Add row (no delete) + renumber
  =============================== */
  function renumberRowsAndNames() {
    const rows = Array.from(tbody.querySelectorAll("tr"));
    rows.forEach((tr, idx) => {
      const n = idx + 1;

      tr.querySelector(".row-no")?.textContent = String(n);

      const itemId = tr.querySelector("input.item-id");
      if (itemId) itemId.name = `item_id_${n}`;

      const qty = tr.querySelector("input.qty-input");
      if (qty) qty.name = `quantity_${n}`;

      const price = tr.querySelector("input.price-input");
      if (price) price.name = `unit_price_${n}`;

      const amount = tr.querySelector("input.amount-display");
      if (amount) amount.name = `amount_display_${n}`;
    });

    if (rowCountInput) rowCountInput.value = String(rows.length);
  }

  if (addBtn) {
    addBtn.addEventListener("click", () => {
      const currentRows = tbody.querySelectorAll("tr").length;
      if (currentRows >= 30) {
        alert("これ以上追加できません（上限30行）");
        return;
      }

      const newIndex = currentRows + 1;

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="row-no">${newIndex}</td>
        <td class="item-cell">
          <input type="text"
                 class="item-autocomplete nav-input"
                 data-col="0"
                 placeholder=""
                 autocomplete="off">
          <input type="hidden"
                 name="item_id_${newIndex}"
                 class="item-id">
          <div class="item-suggestions" hidden></div>
        </td>
        <td>
          <input type="text"
                 name="quantity_${newIndex}"
                 class="num qty-input nav-input"
                 data-col="1"
                 style="width:80px;">
        </td>
        <td>
          <input type="text"
                 name="unit_price_${newIndex}"
                 class="num price-input nav-input"
                 data-col="2"
                 style="width:100px;">
        </td>
        <td>
          <input type="text"
                 name="amount_display_${newIndex}"
                 class="amount-display"
                 readonly
                 tabindex="-1">
        </td>
      `;
      tbody.appendChild(tr);

      renumberRowsAndNames();
      recalcAll();
    });
  }

  /* ===============================
     Enter = move like Tab (detail table only)
  =============================== */
  function focusNextPrev(el, dir) {
    const focusables = Array.from(
      form.querySelectorAll("#item-rows input, #item-rows select")
    ).filter(node => {
      if (node.disabled) return false;
      if (node.type === "hidden") return false;
      if (node.classList?.contains("amount-display")) return false;
      return true;
    });

    const idx = focusables.indexOf(el);
    if (idx < 0) return;

    const next = focusables[idx + dir];
    if (next) {
      next.focus();
      if (typeof next.select === "function" && next.tagName === "INPUT") next.select();
    }
  }

  tbody.addEventListener("keydown", (e) => {
    const el = e.target;
    if (!el.closest("#item-rows")) return;

    if (e.key === "Enter") {
      const cell = el.closest(".item-cell");
      const box = cell ? cell.querySelector(".item-suggestions") : null;
      const dropdownOpen = box && !box.hidden && box.querySelector(".item-suggest-item");
      if (dropdownOpen) return;

      e.preventDefault();
      e.stopPropagation();
      focusNextPrev(el, e.shiftKey ? -1 : 1);
    }
  }, true);

  // init
  renumberRowsAndNames();
  recalcAll();
});
</script>
